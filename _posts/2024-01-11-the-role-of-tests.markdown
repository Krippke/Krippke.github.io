---
layout: single
classes:
  - wide
title: "The role of tests"
date: 2024-01-11 11:51:49 +0100
header:
  teaser: /assets/images/struggling-developer.jpg
---

<img src="/assets/images/struggling-developer.jpg">

# The Role of Tests

Willkommen zu meinem persönlichen Erfahrungsbericht über meine 12-jährige Reise als Softwareentwickler. In diesem Rückblick möchte ich meine Entwicklung von den Anfängen bis heute teilen und dabei besonders auf die transformative Rolle von automatisierten Tests eingehen. Der Begriff 'Test' im Titel bezieht sich dabei auf eben jene automatisierten Tests, die meine Arbeitsweise und die Qualität meiner Software maßgeblich beeinflusst haben. Lassen Sie uns gemeinsam auf die Höhen und Tiefen dieser Reise blicken, wie ich Herausforderungen überwunden habe und welche Erkenntnisse ich dabei gewonnen habe.

Vor 12 Jahren begann meine Reise als Entwickler. Rückblickend betrachtet war meine Herangehensweise an die Entwicklung von Code-Komponenten ziemlich katastrophal. Basierend auf einer mündlichen Beschreibung einer Funktion, began ich darüber nachzudenken, wie ich das als Programm umsetzen könnte. Nach den ersten Überlegungen begann ich direkt mit der Erstellung der Komponenten. Sobald keine Syntaxfehler mehr zu finden waren, kompilierte ich das gesamte Softwareprojekt und startete es lokal auf meinem PC. Ich navigierte durch die Benutzeroberfläche zu der Stelle, an der das Feature zum Einsatz kam, und klickte herum. Wenn ein Fehler auftrat, überprüfte ich die Log-Dateien, analysierte den Stacktrace und versuchte, den Fehler zu beheben. Dieser Zyklus aus Code erstellen, Software kompilieren, durch die Benutzeroberfläche navigieren und Fehlerbehebung wiederholte sich, bis das Feature scheinbar funktionierte und keine Fehler mehr auftraten.

Nach einigen Monaten Erfahrung aus Entwicklung und Betrieb unserer Anwendung erkannte ich das Potenzial zur Verbesserung. Ein Großteil der Fehler war darauf zurückzuführen, dass sich eine Bibliothek anders verhielt als erwartet. Die Idee: Das Wissen über die im Einsatz befindlichen Bibliotheken erweitern, um falsche Annahmen zu reduzieren. Ich begann, den Quellcode der jeweiligen Bibliothek zu studieren und zu verstehen, wie sie funktionieren. Einige Monate später zeigte sich, dass die Arbeit Früchte trug. Es traten weniger Fehler auf, und wenn sie auftraten, konnten sie schneller identifiziert und behoben werden.

Durch diese Verbesserung wurde ein weiteres Problem offensichtlicher. Der Wissensstand in unserem Team war sehr unterschiedlich. Um uns in den Projekten gegenseitig zu unterstützen, musste jeder Kollege alle Annahmen und das Verhalten der eingesetzten Bibliotheken kennen. Lange Übergabemeetings waren nicht effektiv, und vieles von dem, was besprochen wurde, wurde schnell vergessen. In der Umsetzung waren häufig Fehler enthalten, die in der Testphase vom verantwortlichen Kollegen behoben werden mussten. Die Unterstützung eines Kollegen führte letztendlich zu einer vielfachen Umsetzungszeit. Im Nachhinein war das Fazit: Hätte ich das doch lieber komplett selbst gemacht. Eine Erkenntnis wuchs aus diesen Erfahrungen: Wir müssen davon ausgehen, dass Menschen Fehler machen werden.

Meine Projekte starteten immer mit einem Kundenproblem. Wenn sich herausstellte, dass das Problem am besten durch Software gelöst werden konnte, landete es mit einem vermeintlich fertigen Lösungsansatz auf meinem Tisch. Sätze wie "Mach das so und so, dann haben wir das Problem gelöst" haben mich anfangs beruhigt. Der Berater wusste ja genau, was gebraucht wurde. Im Laufe der Jahre hatte ich jedoch direkt Angstschweiß auf der Stirn, wenn ich so etwas hörte. Warum, fragt ihr euch? Das versuche ich mit dem folgenden Beispiel zu veranschaulichen:

Der Kunde hat einen Termin mit unserem Berater. In diesem einstündigen Termin erläutert der Kunde sein Problem. Der Berater hat einen Vorschlag, der sich scheinbar so anhört, als könnte damit das Problem gelöst werden. Ein paar Tage später habe ich mit dem Berater ein Meeting, in dem mir die grundlegenden Aspekte der benötigten Software erklärt werden. Auf Basis dieser Informationen starte ich mit der Entwicklung. Über die nächsten drei Monate habe ich immer mal wieder kurze Termine mit dem Berater, um den Fortschritt abzugleichen. Immer mit demselben Ergebnis: Geht in die richtige Richtung, weitermachen. Es kommt der Tag, an dem alle benötigten Funktionen umgesetzt sind und manuell getestet wurden. Die Software funktioniert. Die Lösung wird dem Kunden präsentiert. Nach zwei Minuten sagt der Kunde: Das ist überhaupt nicht das, was ich benötige.

Dieses extreme Beispiel soll Folgendes zeigen: Eine Software wird am Ende des Projekts nicht das sein, was zu Beginn des Projekts gedacht war. Wie stark diese Abweichung sein wird, lässt sich beeinflussen. Das ist aber nicht Teil dieses Artikels. Die Software muss in der Lage sein, sich wandeln zu können. Änderungen werden kommen und sind der Regelfall.

Genau diese Wandelbarkeit lässt sich mit meiner ursprünglichen Art der Softwareentwicklung nicht abbilden. Ich müsste bei jeder Änderung wissen, welche Auswirkungen diese auf die anderen Komponenten der Software haben wird. Da der Mensch ziemlich vergesslich ist, werden früher oder später Fehler passieren. Um hier auf Nummer sicher zu gehen, müssten alle Aspekte der Software nochmals manuell getestet werden. Dies setzt voraus, dass entsprechendes Verhalten dokumentiert ist und Beschreibungen vorliegen, welche Verhalten wie zu testen sind. Ganz zu schweigen von dem zeitlichen Aufwand, der hinter der ganzen Arbeit stecken würde.

Über die Jahre habe ich immer wieder von verschiedenen Arten von automatisierten Tests gelesen. Unittests, Integrationstests, Ende-zu-Ende-Tests waren für mich Begriffe theoretischer Natur und nichts, womit ich in meiner täglichen Arbeit in Kontakt kam. Ich hatte immer mal wieder versucht, automatisierte Tests für meine Komponenten zu erstellen. Es ist jedoch immer daran gescheitert, weil ich nicht wusste, wie ich Tests in unserer Software erstellen soll. Jetzt kann ich sagen, das Hindernis für Unittests war rückblickend unsere Softwarearchitektur. Es waren keine Grenzen definiert, Komponenten waren überlagert von Verantwortlichkeiten. Für einen Unittest mussten fast alle Komponenten der gesamten Software initialisiert werden. Das Thema Software-Architektur heben wir uns für einen weiteren Post auf.

<img src="/assets/images/celebrating.jpg">

Fast 8 Jahre nachdem ich mit der Softwareentwicklung angefangen habe, war ich nun in der Lage, Tests zu schreiben. Die positiven Auswirkungen zeigten sich schnell. Nach 8 Jahren ohne Tests hat man einige Erfahrung gesammelt und weiß die Vorzüge von automatisierten Tests zu schätzen:

- **Tests sind die Definition von Verhalten:**
  Während ich eine Komponente erstelle, weise ich dieser bestimmte Verhalten zu. Für jedes erwartete Verhalten schreibe ich einen Test, der sicherstellt, dass die Komponente das tut, was ich erwarte. Dadurch schreibe ich meine Gedanken zum Zeitpunkt der Erstellung der Komponente in Form der Tests fest. Fragen wie "Was war nochmal die Aufgabe dieser Komponente?" stellen sich damit nicht mehr. Ich kann mir die Tests anschauen und sehe, was die Komponente machen soll.
- **Tests führen zu einer besseren API:**
  Wenn ich damals Komponenten erstellt habe, kam es oft vor, dass ich bei der späteren Nutzung dieser Komponenten festgestellt habe, dass die API unschön zu nutzen ist. Seitdem ich Tests schreibe, merke ich bereits während der Erstellung der Komponente, ob die API gut zu nutzen ist oder nicht. Ich bin motiviert, die API benutzerfreundlich zu gestalten, da ich gezwungen bin, diese selbst für die Erstellung meiner Tests zu verwenden.
- **Tests als Wegweiser für Anpassungen:**
  Bei Anpassungen an bestehender Software benötigt der Entwickler nicht zwingend umfassendes Wissen darüber, wie die Software im Detail funktioniert. Die Definitionen, die das Verhalten der Komponenten festlegen, sind durch Tests umfassend dokumentiert. Im Falle einer Anpassung, die eine ursprüngliche Annahme verletzt, weist der fehlschlagende Test den Entwickler gezielt auf das Problem hin.
- **Tests decken konzeptionelle Probleme früh auf:**
  In der Softwareentwicklung bewegt man sich auf einem binären Terrain – es funktioniert oder nicht. Im Prozess der Umsetzung von Konzepten und Ideen, die das Produkt menschlicher Gedanken sind, werden frühzeitig konzeptionelle Hürden sichtbar. Eine zeitige Identifikation dieser Probleme reduziert den Zeitaufwand für die Umsetzung erheblich. Das Verfassen von Tests spielt dabei eine entscheidende Rolle, um das reibungslose Zusammenspiel der Komponenten zu evaluieren.
- **Tests helfen bei der Skalierung:**
  Eine Software ohne Tests setzt voraus, dass jeder beteiligte Entwickler sich mit der Software im Detail auskennt. Das sorgt dafür, dass ein Entwickler viel Zeit aufwenden muss, um sinnvolle Code-Beiträge leisten zu können. Eine Software mit Tests ermöglicht, dass weniger erfahrene Entwickler Beiträge leisten können, da die benötigten Verhalten durch Tests sichergestellt werden. Durch das Vorhandensein von Tests bin ich in der Lage, Arbeitspakete zu definieren und diese an Kollegen mit geringem Zeitaufwand zu übergeben. Das Arbeitsergebnis des Kollegen lässt sich durch seine Tests schnell bewerten. Anpassungen können bei Bedarf mit minimalem Aufwand vorgenommen werden.
- **Tests führen zu einer besseren Software-Architektur:**
  Tests für eine Software mit einer schlechten Architektur zu schreiben, ist sehr aufwendig. Ändere ich eine Komponente und bin dann gezwungen, hunderte bzw. tausende von Tests anzupassen, steigt meine Motivation, daran etwas zu ändern. Fällt es einem schwer, einen Test für eine Komponente zu erstellen, wird man sich Gedanken machen, wie es besser geht. Häufig führt dies dazu, dass Verantwortlichkeiten klarer werden. Tests für Software mit einer guten Architektur lassen sich einfach und schnell erstellen.
- **Tests sind die Grundlage für agiles Arbeiten:**
  Die Anforderungen an eine Software wandeln sich stetig. Automatisierte Tests helfen bei der Anpassung, Fehlerbehebung oder Erweiterung. Eine Software besteht aus Tausenden von Komponenten. Jeder Komponente sind Verantwortlichkeiten zugeordnet. Manuelle Tests sind die Folge. Praktisch jedoch nicht umsetzbar.
- **Tests helfen beim Verstehen des Verhaltens einer Bibliothek oder eines Frameworks:**
  Wenn ich heute eine Komponente aus einer Bibliothek einsetze, schreibe ich ein paar Tests, die meine Annahmen überprüfen. Stellt sich heraus, dass mein Wissensstand zu der Komponente nicht ausreichend ist und meine Annahmen falsch sind, schlägt der Test fehl. Dies gibt mir Gelegenheit, meine Annahmen durch Lesen der Dokumentation oder des Quellcodes anzupassen. Sobald der Test erfolgreich durchläuft, kann ich davon ausgehen, dass ich ein ausreichend richtiges Verständnis aufgebaut habe. Ein weiterer Vorteil ergibt sich für den Lebenszyklus der Bibliothek in der Software. Wenn sich die Bibliothek in einer neueren Version anders verhalten sollte als ursprünglich, wird ein Test fehlschlagen, und ich als Entwickler habe damit die Gelegenheit, mich damit auseinanderzusetzen. Das sorgt bei mir für ein Sicherheitsgefühl, was mich dabei unterstützt, die Versionen meiner eingesetzten Bibliotheken aktuell zu halten.

## Fazit

Zusammenfassend kann ich sagen, dass automatisierte Tests nicht nur zu einer höheren Codequalität geführt haben, sondern auch zu einer nachhaltigeren und effizienteren Art der Softwareentwicklung. Die gewonnenen Erkenntnisse haben meine Herangehensweise an Projekte revolutioniert und tragen maßgeblich zu meinem Verständnis von guter Softwarearchitektur bei. Die Entscheidung, Tests als integralen Bestandteil meines Entwicklungsprozesses zu etablieren, erwies sich als Schlüssel für eine erfolgreiche und zukunftsorientierte Softwareentwicklung.
